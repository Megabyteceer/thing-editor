import L from "thing-editor/js/engine/utils/l.js";
import Lib from "thing-editor/js/engine/lib.js";

let prefixToCutOff;

function isFileNameValidForBuild(prefabName) {
	return !prefabName.startsWith(prefixToCutOff) && (prefabName.indexOf('/' + prefixToCutOff) < 0);
}

function filterObjectsData(obj) {
	let ret = {};
	for(let name of Object.keys(obj).filter(isFileNameValidForBuild).sort()) {
		ret[name] = obj[name];
	}
	return ret;
}

const filterChildrenByName = (childData) => {
	if(!childData.hasOwnProperty('p')) {
		return true;
	}
	if(childData.p.hasOwnProperty('name') &&
		childData.p.name.startsWith(prefixToCutOff)) {
		return false;
	}
	if(childData.p.hasOwnProperty('prefabName') &&
		!isFileNameValidForBuild(childData.p.prefabName)) {
		return false;
	}
	return true;
};

const fieldsFilter = (key, value) => {
	if(!key.startsWith(prefixToCutOff)) {
		if(key === ':' && Array.isArray(value)) { // cut off __ objects
			return value.filter(filterChildrenByName);
		}
		return value;
	}
	if(typeof value === 'object') { //its prefab or scene data
		if(isFileNameValidForBuild(key)) {
			return value;
		}
	}
};


export default class Build {
	static async build(debug) {
		prefixToCutOff = (debug ? '___' : '__');
		let scenes = filterObjectsData(Lib._getAllScenes());
		let prefabs = filterObjectsData(Lib._getAllPrefabs());
		
		let images = Lib.__texturesList.filter(n => !Lib.getTexture(n.name).__noIncludeInToBuild).map((t) => {
			return t.value;
		});
		images = images.slice().filter(isFileNameValidForBuild).sort();

		let resources;
		let resourcesMetadata = {};
		for(let r in Lib.resources) {
			if(!resources) {
				resources = [];
			}
			resources.push(r);
			
			if (Lib.resources[r].metadata) {
				resourcesMetadata[r] = Lib.resources[r].metadata;
			}
		}
		if(resources) {
			resources = resources.filter(isFileNameValidForBuild).sort();
		}
		
		let sounds = filterObjectsData(Lib.__getSoundsData());

		let projectDesc = editor.projectDesc;

		let assetsObj = {scenes, prefabs, images, resources, resourcesMetadata, sounds, projectDesc};
		if(editor.projectDesc.embedLocales) {
			assetsObj.text = L.__getTextAssets();
		}

		let assertCode = '';
		if(debug) {
			assertCode = `if(window._thingEngineAssets) {
				alert('window._thingEngineAssets already defined.');	
			};`;
		}

		await editor.fs.saveFile('assets.js', assertCode + 'window._thingEngineAssets = ' +
		JSON.stringify(assetsObj, fieldsFilter) + ';', false, true);
		
		let classesSrc = editor.ClassesLoader.gameObjClasses.concat(editor.ClassesLoader.sceneClasses);
		classesSrc.sort((a, b) => {
			if(a.c.name > b.c.name) {
				return 1;
			} else if (a.c.name < b.c.name) {
				return -1;
			}
			return 0;
		});
		let src = [`/* this file is generated by thing-editor.
Please do not modify it. Any changes will be overriden anyway.*/

import Lib from "thing-editor/js/engine/lib.js";
let classes = {};`];
		let defaults = {};

		const findRef = (class_) => {
			let name = class_.name;
			if(findClassNameInData(name, scenes) || findClassNameInData(name, prefabs)) {
				return 'direct-include';
			}
			return classesSrc.some((c) => {
				return (c.c.prototype instanceof class_) && findRef(c.c.prototype.constructor);
			});
		};

		for(let c of classesSrc) {
			let name = c.c.name;
			let path = editor.ClassesLoader.getClassPath(name);
			if(path) {

				if(path.startsWith('/')) {
					path = path.substr(1);
				}
				path = path.replace('games/' + editor.currentProjectDir, '');

				let isReferred = findRef(c.c);
				if(isReferred) { //only referenced classes
					src.push('import ' + name + ' from "' + path + '";');
					src.push('classes["' + name + '"] = ' + name + ';');
					if(isReferred === 'direct-include') {
						defaults[name] = editor.ClassesLoader.classesDefaultsById[name];
					}
				}
			}
		}
		src.push('Lib._setClasses(classes, ' + JSON.stringify(defaults, fieldsFilter) + ');');
		await editor.fs.saveFile('src/classes.js', src.join('\n'), false, true);

		const result = await editor.fs.getJSON('/fs/build' + (debug ? '?debug=1' : ''));

		if(!result.isSuccess) {
			editor.ui.modal.showError(R.div({dangerouslySetInnerHTML: {__html: result.output}}), 30006);
		} else if(!editor.buildProjectAndExit) {
			let url = '/games/' + editor.currentProjectDir + (debug ? 'debug' : 'release');
			
			editor.openUrl(url);
					
			if(result.output) {
				editor.ui.modal.showModal(R.div({style:{textAlign: 'left'}, dangerouslySetInnerHTML: {__html: result.output}}));
			}
		}

	}
}

function findClassNameInData(name, data) {
	for(let prefabName in data) {
		if(findClassNameInPrefabData(name, data[prefabName])) return true;
	}
}

function findClassNameInPrefabData(name, data) {
	if(!filterChildrenByName(data)) {
		return false;
	}
	if(data.c === name) {
		return true;
	}
	if(data.hasOwnProperty(':')){
		return data[':'].some((d) => {
			return findClassNameInPrefabData(name, d);
		});
	}
}
