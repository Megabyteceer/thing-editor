import { KeyedMap, SerializedObject, SerializedObjectProps, SourceMappedConstructor } from "thing-editor/src/editor/env";
import fs, { AssetType, FileDesc, FileDescClass } from "thing-editor/src/editor/fs";
import game from "thing-editor/src/engine/game";

let prefixToCutOff: '___' | '__';

function isFileNameValidForBuild(name: string) {
	return !name.startsWith(prefixToCutOff) && (name.indexOf('/' + prefixToCutOff) < 0);
}

function filterAssets(file: FileDesc) {
	return isFileNameValidForBuild(file.assetName);
}

const filterChildrenByName = (childData: SerializedObject) => {
	if(!childData.hasOwnProperty('p')) {
		return true;
	}
	if(childData.p.hasOwnProperty('name') &&
		childData.p.name.startsWith(prefixToCutOff)) {
		return false;
	}
	if(childData.p.hasOwnProperty('prefabName') &&
		!isFileNameValidForBuild(childData.p.prefabName)) {
		return false;
	}
	return true;
};

const fieldsFilter = (key: string, value: any) => {
	if(!key.startsWith(prefixToCutOff)) {
		if(key === ':' && Array.isArray(value)) { // cut off __ objects
			return value.filter(filterChildrenByName);
		}
		return value;
	}
	if(typeof value === 'object') { //its prefab or scene data
		if(isFileNameValidForBuild(key)) {
			return value;
		}
	}
};

function getAssetsForBuild(type: AssetType) {
	return fs.getAssetsList(type).filter(filterAssets);
}

export default class Build {
	static build(debug: boolean) {

		//TODO game.editor.validateResources();

		prefixToCutOff = (debug ? '___' : '__');
		let scenes = getAssetsForBuild(AssetType.SCENE);
		let prefabs = getAssetsForBuild(AssetType.PREFAB);

		let images = getAssetsForBuild(AssetType.IMAGE).map(f => f.fileName);

		let resources = {};
		/* TODO for(let name in Lib.resources) {
			if(isFileNameValidForBuild(name)) {
				resources[name] = {};
			}
		} */

		let projectDesc = game.editor.projectDesc;

		let sounds = getAssetsForBuild(AssetType.SOUND).map(f => f.assetName);
		/*TODO let sounds = {};
		for(let sndName in soundsSrc) {
			let sndData = soundsSrc[sndName];
			sndData = sndData.filter((sndSrc) => {
				return projectDesc.soundFormats.some(ext => sndSrc.endsWith(ext));
			});
			if(typeof (editor.ui.soundsList.soundsDurations[sndName]) === 'number') {
				sndData.push(editor.ui.soundsList.soundsDurations[sndName]);
			}
			sounds[sndName] = sndData;
		}*/

		let assetsObj = {
			scenes: scenes.map(f => f.fileName),
			prefabs: prefabs.map(f => f.fileName),
			images,
			resources,
			sounds,
			projectDesc
		};
		/* TODO
		if(game.editor.projectDesc.embedLocales) {
			assetsObj.text = L.__getTextAssets();
		}*/

		fs.writeFile(game.editor.currentProjectDir + 'assets.ts', 'export default ' +
			JSON.stringify(assetsObj, fieldsFilter) + ';');

		let classesFiles = getAssetsForBuild(AssetType.CLASS) as FileDescClass[];
		classesFiles.sort((a, b) => {
			if(a.assetName > b.assetName) {
				return 1;
			} else if(a.assetName < b.assetName) {
				return -1;
			}
			return 0;
		});

		let src = [`/* this file is generated by thing-editor.
Please do not modify it. Any changes will be overriden anyway.*/

import Lib from "thing-editor/src/engine/lib";
let classes = {};`];
		let defaults: KeyedMap<SerializedObjectProps> = {};

		const findRef = (class_: SourceMappedConstructor): boolean => {
			let name = class_.__className;
			if(findClassNameInAssetFiles(name, scenes) || findClassNameInAssetFiles(name, prefabs)) {
				return true;
			}
			return classesFiles.some((c: FileDescClass) => {
				return (c.asset.prototype instanceof class_) && findRef(c.asset.prototype.constructor as SourceMappedConstructor);
			});
		};

		for(let classFile of classesFiles) {
			let name = classFile.assetName;
			let path = classFile.fileName;

			/* TODO remove?	
			if(path.startsWith('/')) {
				path = path.substr(1);
			}
			if(path.startsWith('games/')) {
					path = game.editor.currentProjectDir.split('/').map(() => { return '..'; }).join('/') + '/../' + path;
				}*/
			let isReferred = findRef(classFile.asset);
			if(isReferred) { //only referenced classes
				src.push('import ' + name + ' from "' + path + '";');
				src.push('classes["' + name + '"] = ' + name + ';');
				if(isReferred) {
					defaults[name] = classFile.asset.__defaultValues;
				}
			}

		}
		src.push('Lib._setClasses(classes, ' + JSON.stringify(defaults, fieldsFilter) + ');');
		fs.writeFile(game.editor.currentProjectDir + 'classes.ts', src.join('\n'));

		const reversedDirsList = game.editor.assetsFolders.slice().reverse();

		for(let dir of reversedDirsList) {
			const htmlName = dir + 'index.html';
			if(fs.exists(htmlName)) {
				fs.copyFile(htmlName, game.editor.currentProjectDir + 'index.html');
				break;
			}
		}

		/*	const result = fs.build(game.editor.currentProjectDir, debug);
	
			if(!result) {
				game.editor.ui.modal.showError(R.multilineText(result), 30006);
			} else if(!game.editor.buildProjectAndExit) {
				let url = game.editor.currentProjectDir + (debug ? 'debug' : 'release');
	
				game.editor.openUrl(url);
	
				if(result) {
					game.editor.ui.modal.showModal(R.multilineText(result));
				}
			}*/
	}
}

function findClassNameInAssetFiles(className: string, assets: FileDesc[]) {
	for(let prefab of assets) {
		if(findClassNameInPrefabData(className, prefab.asset as SerializedObject)) return true;
	}
}

function findClassNameInPrefabData(name: string, data: SerializedObject): boolean {
	if(!filterChildrenByName(data)) {
		return false;
	}
	if(data.c === name) {
		return true;
	}
	if(data.hasOwnProperty(':')) {
		return data[':']!.some((d) => {
			return findClassNameInPrefabData(name, d);
		});
	}
	return false;
}
