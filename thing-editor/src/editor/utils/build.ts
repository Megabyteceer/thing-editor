import { AssetsDescriptor, KeyedMap, SerializedObject, SourceMappedConstructor } from "thing-editor/src/editor/env";
import fs, { AssetType, FileDesc, FileDescClass, FileDescImage, FileDescPrefab, FileDescScene, FileDescSound } from "thing-editor/src/editor/fs";
import game from "thing-editor/src/engine/game";
import Lib from "thing-editor/src/engine/lib";

let prefixToCutOff: '___' | '__';

function isFileNameValidForBuild(name: string) {
	return !name.startsWith(prefixToCutOff) && (name.indexOf('/' + prefixToCutOff) < 0);
}

function filterAssets(file: FileDesc) {
	return isFileNameValidForBuild(file.assetName);
}

const filterChildrenByName = (childData: SerializedObject) => {
	if(!childData.hasOwnProperty('p')) {
		return true;
	}
	if(childData.p.hasOwnProperty('name') &&
		childData.p.name.startsWith(prefixToCutOff)) {
		return false;
	}
	if(childData.p.hasOwnProperty('prefabName') &&
		!isFileNameValidForBuild(childData.p.prefabName)) {
		return false;
	}
	return true;
};

const fieldsFilter = (key: string, value: any) => {
	if(!key.startsWith(prefixToCutOff)) {
		if(key === ':' && Array.isArray(value)) { // cut off __ objects
			return value.filter(filterChildrenByName);
		}
		return value;
	}
	if(typeof value === 'object') { //its prefab or scene data
		if(isFileNameValidForBuild(key)) {
			return value;
		}
	}
};

function getAssetsForBuild(type: AssetType.CLASS): FileDescClass[];
function getAssetsForBuild(type: AssetType.SOUND): FileDescSound[];
function getAssetsForBuild(type: AssetType.IMAGE): FileDescImage[];
function getAssetsForBuild(type: AssetType.PREFAB): FileDescPrefab[];
function getAssetsForBuild(type: AssetType.SCENE): FileDescScene[];
function getAssetsForBuild(type: AssetType) {
	return fs.getAssetsList(type).filter(filterAssets);
}

let currentBuildIsDebug = false;

export default class Build {
	static build(debug: boolean) {
		currentBuildIsDebug = debug;

		const assetsToCopy: { from: string, to: string }[] = [];

		if(game.editor.askSceneToSaveIfNeed() === false) {
			return;
		}
		game.editor.ui.modal.showSpinner();

		//TODO game.editor.validateResources();

		prefixToCutOff = (debug ? '___' : '__');
		let scenesFiles = getAssetsForBuild(AssetType.SCENE);
		let prefabsFiles = getAssetsForBuild(AssetType.PREFAB);

		let images = getAssetsForBuild(AssetType.IMAGE).filter(f => !Lib.__isSystemTexture(f.asset)).map((imageFile) => {
			assetsToCopy.push({
				from: imageFile.fileName,
				to: imageFile.assetName
			});
			return imageFile.assetName;
		});

		let resources = {};
		/* TODO for(let name in Lib.resources) {
			if(isFileNameValidForBuild(name)) {
				resources[name] = {};
			}
		} */

		let projectDesc = game.editor.projectDesc;

		let sounds = getAssetsForBuild(AssetType.SOUND).map(f => f.assetName);
		/*TODO let sounds = {};
		for(let sndName in soundsSrc) {
			let sndData = soundsSrc[sndName];
			sndData = sndData.filter((sndSrc) => {
				return projectDesc.soundFormats.some(ext => sndSrc.endsWith(ext));
			});
			if(typeof (editor.ui.soundsList.soundsDurations[sndName]) === 'number') {
				sndData.push(editor.ui.soundsList.soundsDurations[sndName]);
			}
			sounds[sndName] = sndData;
		}*/

		const scenes: KeyedMap<SerializedObject> = {};
		const prefabs: KeyedMap<SerializedObject> = {};

		for(const file of scenesFiles) {
			scenes[file.assetName] = file.asset;
		}
		for(const file of prefabsFiles) {
			prefabs[file.assetName] = file.asset;
		}

		let assetsObj: AssetsDescriptor = {
			scenes,
			prefabs,
			images,
			resources,
			sounds,
			projectDesc
		};
		/* TODO
		if(game.editor.projectDesc.embedLocales) {
			assetsObj.text = L.__getTextAssets();
		}*/

		fs.writeFile(
			game.editor.currentProjectDir + '.tmp/assets-preloader.ts',
			'export default ' +
			JSON.stringify(assetsObj, fieldsFilter) + ';');

		let classesFiles = getAssetsForBuild(AssetType.CLASS) as FileDescClass[];
		classesFiles.sort((a, b) => {
			if(a.assetName > b.assetName) {
				return 1;
			} else if(a.assetName < b.assetName) {
				return -1;
			}
			return 0;
		});

		let src = [`/* this file is generated by thing-editor.
	Please do not modify it. Any changes will be overridden anyway.*/

	import { KeyedObject, SourceMappedConstructor } from "thing-editor/src/editor/env";
	import Lib from "thing-editor/src/engine/lib";
	const classes:KeyedObject = {};`];

		const findRef = (class_: SourceMappedConstructor): boolean => {
			let name = class_.__className;
			if(findClassNameInAssetFiles(name, scenesFiles) || findClassNameInAssetFiles(name, prefabsFiles)) {
				return true;
			}
			return classesFiles.some((c: FileDescClass) => {
				return (c.asset.prototype instanceof class_) && findRef(c.asset.prototype.constructor as SourceMappedConstructor);
			});
		};

		for(let classFile of classesFiles) {
			let name = classFile.asset.__className;
			let path = classFile.fileName;

			if(path.startsWith('/')) {
				path = path.substr(1);
			}

			let isReferred = findRef(classFile.asset);
			if(isReferred) { //only referenced classes go in to build
				src.push('import ' + name + ' from "' + path + '";');
				src.push('classes["' + name + '"] = ' + name + ';');
				src.push('(' + name + ' as any as SourceMappedConstructor).__defaultValues = ' + JSON.stringify(classFile.asset.__defaultValues, fieldsFilter) + ';');
			}
		}

		src.push('Lib._setClasses(classes);');
		fs.writeFile(game.editor.currentProjectDir + '.tmp/classes.ts', src.join('\n'));

		const reversedDirsList = game.editor.assetsFolders.slice().reverse();

		for(let dir of reversedDirsList) {
			const htmlName = dir + 'index.html';
			if(fs.exists(htmlName)) {
				fs.copyFile(htmlName, game.editor.currentProjectDir + '.tmp/index.html');
				break;
			}
		}

		fs.build(game.editor.currentProjectDir, debug, assetsToCopy);
	}

	static showResult(result: any) {
		game.editor.ui.modal.hideSpinner();
		result = JSON.parse(result);
		if(!game.editor.buildProjectAndExit) {
			let url = game.editor.currentProjectDir + (currentBuildIsDebug ? 'debug/' : 'release/');
			game.editor.openUrl('/' + url);
			//TODO errors parsing
			//	game.editor.ui.modal.showModal(R.multilineText(result));
		}
	}
}

thingEditorServer.onServerMessage((_ev: any, event: string, path: string) => {
	if(event === 'fs/buildResult') {
		Build.showResult(path as any);
	}
});

function findClassNameInAssetFiles(className: string, assets: FileDesc[]) {
	for(let prefab of assets) {
		if(findClassNameInPrefabData(className, prefab.asset as SerializedObject)) return true;
	}
}

function findClassNameInPrefabData(name: string, data: SerializedObject): boolean {
	if(!filterChildrenByName(data)) {
		return false;
	}
	if(data.c === name) {
		return true;
	}
	if(data.hasOwnProperty(':')) {
		return data[':']!.some((d) => {
			return findClassNameInPrefabData(name, d);
		});
	}
	return false;
}
